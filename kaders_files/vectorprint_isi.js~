/*
 
 ************************************************************
 * Ecmascript module voor positioneren van plaatjes in een        *
 * document, het toewijzen van plaatjes aan frames en het         *
 * rechthoekig of elliptisch uitsnijden van plaatjes.             *
 *                                                                *
 * Auteur: Eduard Drenth                                          *
 * Versie: 1.0                                                    *
 *                                                                *
 * Ontwikkeld voor Indepenent System Integrators door             *
 * VectorPrint, 2005.                                             *
 *                                                                *
 * VectorPrint                                                    *
 * Jhr. A.F. de S. Lohmanstraat 38                                *
 * 8802 RH Franeker                                               *
 * +31 517 390907                                                 *
 * eduarddrn@netscape.net                                         *
 *                                                                *
 ************************************************************
 
 DOCUMENTATIE
 
 LET OP VANAF 2005-09-10: VIEWBOX NIET ONDERSTEUND!!!
 LETOP ALLE MATEN IN DE SVG MOETEN ZONDER UNIT (MM, PT ETC) GEGEVEN WORDEN!!!!
 
 standaard attributen in voor svg elementen:
 
 bij het rootelement:
 ---------------------------------- 2005-09-10 ONGELDIG -----------------------------------------------------
 
 - @viewBox: bestaat uit x, y, width, height (bijv. viewBox="0 0 1200 1200").
 Hiermee leg je het coordinatenstelsel vast, alle maten in de svg worden t.o.v. dit
 stelsel berekend.
 
 Stel de volgende svg voor:
 <svg width="15mm" height="12mm" viewBox="0 0 150 120">
 <rect height="100" width="100" x="2" y="2" style="stroke:black;stroke-width:1px"/>
 </svg>
 De rectangle zal x/y coordinaten 0.2mm/0.2mm hebben en een width/height van 10mm/10mm
 
 Als in de svg harde maten (met een unit eraan bijv. 10mm of 8pt) gebruikt worden zullen de
 resultaten onvoorspelbaar zijn!
 
 ---------------------------------- EINDE ONGELDIG ------------------------------------------------------------
 
 attributen in de vectorprint namespace:
 
 bij het root element:
 
 - @rulers, waarde "true" boven en linkerkant krijgen een lineaal
 - @crop, waarde "true" een uitsnijder wordt getoond
 - @guides, waarde "true" als een uitsnijder wordt gebruikt dan krijgt deze guides
 - @croptool_inactive_style, een css style die aan de uitsnijder wordt toegekend als deze niet actief is
 - @croptool_active_style, een css style die aan de uitsnijder wordt toegekend als deze actief is
 - @requestmethod: waarde "post" zal leiden tot een post request (zonder variabelen, raw data!!),
 waarde "get" (default) zal leiden tot een get request (met variabelen, beperkt tot 2083 characters voor IE,
 en tot 255 characters voor de querystring op sommige servers)
 
 zowel "get" als "post" zullen een request vanuit de SVG Module sturen en de response ook in de module
 verwerken.
 
 Als het wenselijk is om vanuit de module een request via de browser te sturen kan waarde "html" gebruikt
 worden. In dit geval zal de module via de browser een request sturen, de response wordt ook via de browser
 verwerkt.
 
 bij een image element
 
 - @image, indien aanwezig dan wordt dit image opgenomen als te manipuleren image
 - @id, moet aanwezig zijn als @image gezet is, identificeert een image
 - @cropallowed, waarde "true" geeft aan dat dit image uitgesneden mag worden
 - @dpi, de originele resolutie
 - @mindpi, de minimale resolutie die is toegestaan
 - @resizeoncrop, waarde "true" geeft aan dat bij uitsnijden de uitsnede proportioneel vergroot
 wordt tot de originele maat van het image. Dit vergroten gebeurt alleen als de maat van het image
 nog niet is gewijzigd.
 - @dragallowed, waarde "true" geeft aan dat dit image verplaatst mag worden
 - @dragstyle, een css style die aan het image wordt toegekend tijdens slepen
 
 bij een rect element
 
 - @frame, indien aanwezig dan wordt deze rect opgenomen als een frame waarin een image gedropped kan worden
 - @id, moet aanwezig zijn als @frame gezet is, identificeert een frame
 - @fit, waarden "both", "width" of "height" geeft aan hoe een image wordt gescaled als het in een frame wordt gedropped
 - @align, waarden "left", "right", "center" horizontale positie van een image in een frame
 - @valign, waarden "top", "bottom", "center" vertikale positie van een image in een frame
 - @highlightstyle, een css style die aan het frame wordt toegekend als een image boven het frame gesleept wordt
 - @multipleimages, sta meerdere images toe in een frame, dit sluit @align, @valign en @fit uit
 - @checksize, waarden "true" (default) er wordt gecontroleert of het image in het frame past, of "false"
 NB als een image uitgesneden is wordt gecontroleerd of het uitgesneden deel past.
 - @checkinside, waarden "true" (default) er wordt gecontroleert of delen van het image buiten het frame zitten, of "false"
 NB als een image uitgesneden is wordt gecontroleerd of het uitgesneden deel er buiten zit.
 
 VERDERE FEATURES
 
 Er kan een variabele opgenomen worden in een script die aan geeft welk type uitsnijder gebruikt wordt.
 Dit script moet voor het vectorprint script opgenomen worden in de svg.
 
 var svgclipelement, waarden "rect" of "ellipse" geeft de vorm van de uitsnijder aan.
 
 Als er een text element met id="status" wordt opgenomen dan zal hierin informatie getoond worden tijdens
 slepen en croppen.
 
 Als er een text element met id="help" wordt opgenomen dan zal hierin helptext getoond worden.
 
 In de root moet onload="init(evt, url)" worden opgenomen. het evt argument is vast, de url is de url waarnaar
 de verzamelde gegevens gestuurd worden.
 
 De gebruikte maten in de svg moeten zonder eenheden opgegeven worden, anders zijn er vreemde
 effecten te verwachten.
 
 De teruggestuurde gegevens zullen uitgedrukt zijn in pixels.
 Het formaat van de teruggestuurde informatie is als volgt (op de plek van <x> zal een geheel getal staan):
 
 <imageid>=x:<xcoordinaat>y:<xcoordinaat>width:<width>height:<height>,frame:<frameid>,crop(x:<x>y:<y>w:<w>h:<h>)
 
 Dus ieder imageid is een http parameter bij gebruik van de GET methode. Frame en/of crop informatie ontbreken als
 een image niet in een frame geplaatst is en/of niet is uitgesneden.
 
 Een image kan worden "gereset" door er met de rechtermuisknop op te klikken
 
 */
var svgns = 'http://www.w3.org/2000/svg';
var xlinkns = 'http://www.w3.org/1999/xlink';
var vectorprintns = 'http://www.vectorprint.nl/2005/dynsvg';
var vectorprintprefix='vp:';

var resulturl = '';

var svg = document.getElementsByTagNameNS(svgns,"svg")[0];

svg.setAttribute( 'onmousedown', 'Grab(evt)');
svg.setAttribute( 'onmousemove', 'Drag(evt)');
svg.setAttribute( 'onmouseup', 'Drop(evt)');

var TrueCoords = svg.createSVGPoint(); // coordinaten aangepast aan de schaal (zoom en verschuiven)
var GrabPoint = svg.createSVGPoint(); // waar hebben we met de muis geklikt

var croptool_active_style = 'fill:black;fill-opacity:0.1;stroke:black;stroke-width:1px;stroke-opacity:1';
var fill = 'fill:black;fill-opacity:0.1;stroke:black;stroke-width:1px;stroke-opacity:1'; // voor de Handles....
var croptool_inactive_style = 'fill:black;fill-opacity:0;';
var margin = 10;
var pathid = 'ClipPathId'

var defs = null;
var ok = null;
var croptool = null;

var cropimages = new Object();
var images = new Object();
var frames = new Object();

var dragobject = null;

var statustext = null;
var helptext = null;
var helptexttext = 'U kunt de plaatjes slepen en/of uitsnijden';

var i = 0;

function showHelp(help) {
   if (helptext) {
      helptext.data = help;
   }
}

function init(evt, resultURL) {
   this.resulturl = resultURL;

   if (!svg.hasAttributeNS(null, 'viewBox')) {


      if (svg.getAttribute('vp:rulers') == 'true') {
         new TopRuler();
         new LeftRuler();
      }

      ok = new OKButton();

      if (svg.getAttribute(vectorprintprefix+'crop') == 'true') {
         defs = create('defs');
         svg.insertBefore(defs, svg.firstChild);
         croptool = new Croptool();
         croptool.addHandles();
         if (svg.getAttribute(vectorprintprefix+'guides') == 'true') {
            croptool.addGuides();
         }
         if (svg.getAttribute(vectorprintprefix+'croptool_inactive_style') != '') {
            croptool_inactive_style = svg.getAttribute(vectorprintprefix+'croptool_inactive_style');
         }
         if (svg.getAttribute(vectorprintprefix+'croptool_active_style') != '') {
            croptool_active_style = svg.getAttribute(vectorprintprefix+'croptool_active_style');
         }
         croptool.positionGuidesAndHandles();
         croptool.fixHandles();
      }


      // zoek de images

      var imagess = svg.getElementsByTagNameNS(svgns, 'image');

      for (i = 0; i < imagess.length; i++) {
         var image = imagess.item(i);
         if (image.getAttribute(vectorprintprefix+'image') != null && image.hasAttributeNS(null, 'id')) {
            image.setAttribute( 'cursor', 'move');
            image.setAttribute( 'onmouseover', "showHelp('rechter muisknop om plaatje te resetten, links om te slepen')");
            images[i] = new Image(image);
            // cropimages[i] = new CropImage(image);

            /*
             
             let op bij croppen:
             
             var rawimage = cropImage.image.cloneNode();
             rawimage.removeAttributeNS(vectorprintns,'cropimage');
             rawimage.setAttributeNS(vectorprintns,'image','');
             
             var im = new Image(rawimage);
             
             images[i] = new Image(im);
             
             */


            //alert(image.x.baseVal.unitType);
            //alert(image.x.baseVal.valueInSpecifiedUnits);
         }
      }

      // zoek de frames

      var framess = svg.getElementsByTagNameNS(svgns, 'rect');

      for (i = 0; i < framess.length; i++) {
         var frame = framess.item(i);
         if (frame.getAttribute(vectorprintprefix+'frame') != null && frame.hasAttributeNS(null, 'id')) {
            frames[i] = new Frame(frame);
         }
      }

      var status = svg.getElementById('status');
      statustext = document.createTextNode('');
      if (status)
         status.appendChild(statustext);

      var info = svg.getElementById('help');
      helptext = document.createTextNode(helptexttext);
      if (info)
         info.appendChild(helptext);

   } else {
      alert('viewBox not supported yet!');
   }
}

function create(name) {
   return document.createElementNS(svgns, name);
}
function append(element) {
   return svg.appendChild(element);
}


function OKButton() {
   this.group = create('a');

   this.rect = create('rect');
   this.rect.setAttribute( 'style', 'fill:yellow;stroke:black;stroke-width:2px;stroke-dasharray:2px 2px;fill-opacity:0.5');
   this.rect.setAttribute( 'x', 50);
   this.rect.setAttribute( 'y', 20);
   this.rect.setAttribute( 'rx', 5);
   this.rect.setAttribute( 'ry', 5);
   this.rect.setAttribute( 'width', 40);
   this.rect.setAttribute( 'height', 30);
   this.rect.setAttribute( 'onmouseover', "showHelp('klik hier op als u klaar bent')");
   this.rect.setAttribute( 'onmouseout', "showHelp('')");

   this.text = create('text');
   this.text.setAttribute( 'x', 55);
   this.text.setAttribute( 'y', 43);
   this.text.setAttribute( 'style', 'font-size:20;fill:green;font-weight:bold;stroke:green;stroke-width:1px;');
   this.text.appendChild(document.createTextNode('OK'));
   this.group.appendChild(this.text);
   this.group.appendChild(this.rect);
   append(this.group);
   var point = this.text.getStartPositionOfChar(0);
   this.x = point.x;
   this.y = point.y;
}
OKButton.prototype.group = null;
OKButton.prototype.text = null;
OKButton.prototype.rect = null;
OKButton.prototype.x = 0;
OKButton.prototype.y = 0;
OKButton.prototype.dragStyle = function () {
}
OKButton.prototype.dropStyle = function () {
}
OKButton.prototype.move = function (x, y) {
   this.group.setAttribute( 'transform', 'translate(' + x + ', ' + y + ')');
};
OKButton.prototype.disableDrag = function () {
   this.group.setAttribute( 'pointer-events', 'none');
}
OKButton.prototype.enableDrag = function () {
   this.group.setAttribute( 'pointer-events', 'all');
}
OKButton.prototype.setStyle = function (style) {
}
OKButton.prototype.fix = function () {
}
function sendInfo() {
   var s = '';
   var sep = '';
   var imagesok = true;
   var framesok = true;
   for (var image in images) {
      if (images[image].image.hasAttribute(vectorprintprefix + 'frame_obligatory') &&
              images[image].frameInfo === '') {
         imagesok = false;
         break;
      }
      s += sep + images[image].info();
      sep = '&';
   }
   for (var frame in frames) {
      if (frames[frame].rect.hasAttribute(vectorprintprefix + 'image_obligatory') &&
              !frames[frame].image) {
         framesok = false;
         break;
      }
   }
   //alert(s);
   if (imagesok) {
      if (framesok) {
         try {
            if (svg.getAttribute(vectorprintprefix+'requestmethod') === 'post') {
               post(resulturl, s);
            }
            if (svg.getAttribute(vectorprintprefix+'requestmethod') === 'get') {
               get(resulturl,s);
            } else {
               ok.group.setAttributeNS(xlinkns, 'xlink:href', resulturl + '?' + s);
            }
         } catch (error) {
            alert('Something failed while trying to reach the server: ' + error.message);
         }
      } else {
         //frames[frame].rect.setAttribute('fill','red');
         alert('frame ' + frames[frame].rect.getAttribute( 'id') + ' has to contain an image!');
      }
   } else {
      images[image].image.setAttribute( 'style', 'opacity:0.3;');
      alert('image ' + images[image].image.getAttribute( 'id') + ' has to be inside a frame!');
   }
}

function TopRuler() {
   this.line = create('line');
   this.line.setAttribute( 'x1', '0');
   this.line.setAttribute( 'x2', '100%');
   this.line.setAttribute( 'y1', '0');
   this.line.setAttribute( 'y2', '0');
   this.line.setAttribute( 'stroke', 'black');
   this.line.setAttribute( 'stroke-width', '6mm');
   this.line.setAttribute( 'stroke-opacity', '0.2');
   this.line.setAttribute( 'stroke-dasharray', '1mm 1mm');
   append(this.line);
   for (i = 1; i < 40; i++)
      append(getRulerText(i, false));
}

function getRulerText(nr, vertical) {
   var text = create('text');
   if (!vertical) {
      text.setAttribute( 'x', nr * 10 + 'mm');
      text.setAttribute( 'y', '6mm');
   } else {
      text.setAttribute( 'y', nr * 10 + 'mm');
      text.setAttribute( 'x', '1mm');
   }
   text.setAttribute( 'style', 'font-size:12;fill:red;font-weight:bold');
   texttext = document.createTextNode(nr);
   text.appendChild(texttext);
   return text;
}

function LeftRuler() {
   this.line = create('line');
   this.line.setAttribute( 'x1', '0');
   this.line.setAttribute( 'x2', '0');
   this.line.setAttribute( 'y1', '0');
   this.line.setAttribute( 'y2', '100%');
   this.line.setAttribute( 'stroke', 'black');
   this.line.setAttribute( 'stroke-width', '6mm');
   this.line.setAttribute( 'stroke-opacity', '0.2');
   this.line.setAttribute( 'stroke-dasharray', '1mm 1mm');
   append(this.line);
   for (i = 1; i < 40; i++)
      append(getRulerText(i, true));
}

function Guide() {
  this.line = create('line');
  this.line.setAttribute( 'x1', 0);
  this.line.setAttribute( 'x2', '10');
  this.line.setAttribute( 'y1', '10');
  this.line.setAttribute( 'y2', '0');
  this.line.setAttribute( 'stroke', 'black');
  this.line.setAttribute( 'stroke-width', '0.3px');
  append(this.line);
}
Guide.prototype.position = function (x, y, width, height) {
}

function LeftGuide() {
   Guide.call(this);
   this.line.setAttribute( 'y1', 0);
   this.line.setAttribute( 'y2', '100%');
}
LeftGuide.prototype = new Guide;
LeftGuide.prototype.constructor = LeftGuide;
LeftGuide.prototype.position = function (x, y, width, height) {
   this.line.setAttribute( 'x1', x);
   this.line.setAttribute( 'x2', x);
}

function RightGuide() {
   Guide.call(this);
   this.line.setAttribute( 'y1', 0);
   this.line.setAttribute( 'y2', '100%');
}
RightGuide.prototype = new Guide;
RightGuide.prototype.constructor = RightGuide;
RightGuide.prototype.position = function (x, y, width, height) {
   this.line.setAttribute( 'x1', x + width);
   this.line.setAttribute( 'x2', x + width);
}

function TopGuide() {
   Guide.call(this);
   this.line.setAttribute( 'x1', 0);
   this.line.setAttribute( 'x2', '100%');
}
TopGuide.prototype = new Guide;
TopGuide.prototype.constructor = TopGuide;
TopGuide.prototype.position = function (x, y, width, height) {
   this.line.setAttribute( 'y1', y);
   this.line.setAttribute( 'y2', y);
}

function BottomGuide() {
   Guide.call(this);
   this.line.setAttribute( 'x1', 0);
   this.line.setAttribute( 'x2', '100%');
}
BottomGuide.prototype = new Guide;
BottomGuide.prototype.constructor = BottomGuide;
BottomGuide.prototype.position = function (x, y, width, height) {
   this.line.setAttribute( 'y1', y + height);
   this.line.setAttribute( 'y2', y + height);
}

function EventCatcher() {
   this.rect = create('rect');
   this.rect.setAttribute( 'fill', 'none');
   this.rect.setAttribute( 'pointer-events', 'all');
   this.rect.setAttribute( 'x', '-20');
   this.rect.setAttribute( 'y', '-20');
   this.rect.setAttribute( 'width', '120%');
   this.rect.setAttribute( 'height', '120%');
   svg.insertBefore(this.rect, svg.firstChild);
}

function Image(image) {
   this.image = image;
   this.x = parseFloat(image.getAttribute( 'x'));
   this.y = parseFloat(image.getAttribute( 'y'));
   this.w = parseFloat(image.getAttribute( 'width'));
   this.h = parseFloat(image.getAttribute( 'height'));
   image.setAttribute( 'preserveAspectRatio', 'none');
   image.setAttribute( 'onmouseout', 'resetMe(evt);');
   var ratio = parseFloat(this.image.getAttribute(vectorprintprefix+'dpi')) / parseFloat(this.image.getAttribute(vectorprintprefix+'mindpi'));
   if (image.getAttribute( 'style') !== '')
      this.style = image.getAttribute( 'style');
   if (image.getAttribute(vectorprintprefix+'dragstyle') !== '')
      this.dragstyle = image.getAttribute(vectorprintprefix+'dragstyle');
   if (image.getAttribute(vectorprintprefix+'cropallowed') === 'true') {
      var clip = create('clipPath');
      defs.appendChild(clip);
      clip.setAttribute( 'id', pathid + image.getAttribute( 'id'));
      clip.appendChild(croptool.svgobject.cloneNode(false));
      this.clip = clip;
   }
   this.maxWidth = ratio * this.w;
   this.maxHeight = ratio * this.h;
}
function resetMe(evt) {
   if (dragobject && (dragobject === croptool || dragobject.sizeBottom === '')) {
      var targetElement = evt.target;
      for (var image in images) {
         if (images[image].image === targetElement) {
            if (!targetElement.hasAttributeNS(null, 'clip-path') || !(images[image].cropx)) {
               images[image].clean();
            }
            break;
         }
      }
   }
   helptext.data = '';
}
Image.prototype.x = 10;
Image.prototype.y = 10;
Image.prototype.cropx = null;
Image.prototype.cropy = null;
Image.prototype.prevTransX = 0;
Image.prototype.prevTransY = 0;
Image.prototype.curTransX = 0;
Image.prototype.curTransY = 0;
Image.prototype.w = 10;
Image.prototype.h = 10;
Image.prototype.clip = null;
Image.prototype.frameInfo = '';
Image.prototype.style = '';
Image.prototype.dragstyle = '';
Image.prototype.maxWidth = 100000;
Image.prototype.maxHeight = 100000;
Image.prototype.resize = function (w, h) {
   this.image.setAttribute( "width", w);
   this.image.setAttribute( "height", h);
}
Image.prototype.clean = function () {
   this.frameInfo = '';
   if (this.image.hasAttributeNS(null, 'clip-path'))
      this.image.removeAttributeNS(null, 'clip-path');
   this.cropx = null;
   this.cropy = null;
   this.reset(this.x, this.y);
}
Image.prototype.crop = function () {
   if (this.image.getAttribute(vectorprintprefix+'cropallowed') == 'true') {
      if (!(this.cropx && this.cropy)) {
         var iw = parseFloat(this.image.getAttribute( "width"));
         var ih = parseFloat(this.image.getAttribute( "height"));
         var ix = parseFloat(this.image.getAttribute( "x"))
         var iy = parseFloat(this.image.getAttribute( "y"));
         var cx = croptool.svgobject.getBBox().x;
         var cy = croptool.svgobject.getBBox().y;
         var cw = croptool.svgobject.getBBox().width;
         var ch = croptool.svgobject.getBBox().height;

         if (this.image.hasAttribute(vectorprintprefix + 'resizeoncrop') && iw == this.w && ih == this.h) {

            factor = ((iw / cw) < (ih / ch)) ? (iw / cw) : (ih / ch);
            // we moeten ook evt. verplaatsen, en wel zo dat het gecropte deel op 0,0 van het huidige
            this.image.setAttribute( "x", (ix - ((cx - ix) * factor)));
            this.image.setAttribute( "y", (iy - ((cy - iy) * factor)));
            this.image.setAttribute( "width", (iw * factor));
            this.image.setAttribute( "height", (ih * factor));

            cw = cw * factor;
            ch = ch * factor;
            croptool.resize(cw, ch);
            croptool.moveTo(ix, iy);
            cx = ix;
            cy = iy;
            iw = parseFloat(this.image.getAttribute( "width"));
            ih = parseFloat(this.image.getAttribute( "height"));
            ix = parseFloat(this.image.getAttribute( "x"));
            iy = parseFloat(this.image.getAttribute( "y"));
         }
         if (this.image.hasAttribute(vectorprintprefix + 'mindpi') && (iw > this.maxWidth || ih > this.maxHeight)) {
            croptool.reset();
            croptool.positionGuidesAndHandles();
            alert('Resolution too low!');
            this.reset(this.x, this.y);
            if (this.image.hasAttributeNS(null, 'clip-path'))
               this.image.removeAttributeNS(null, 'clip-path');
         } else {
            this.cropx = parseFloat(this.image.getAttribute( "x"));
            this.cropy = parseFloat(this.image.getAttribute( "y"));
            croptool.positionGuidesAndHandles();
            dragobject.fix();

            if (this.image.hasAttributeNS(null, 'clip-path'))
               this.image.removeAttributeNS(null, 'clip-path');
            try {
               this.clip.replaceChild(croptool.svgobject.cloneNode(true), this.clip.firstChild);
            } catch (error) {
            }

            this.image.setAttribute( 'clip-path', 'url(#' + this.clip.getAttribute( 'id') + ')');
         }
      } else {
         if (confirm('To define a new cropping region you have to reset this image! Do you wish to do so now?') == true)
         {
            this.clean();
         }
      }
   }
}
Image.prototype.showCrop = function () {
   if (this.image.getAttribute(vectorprintprefix+'cropallowed') == 'true') {
      if (!(this.cropx && this.cropy)) {
         if (this.image.hasAttributeNS(null, 'clip-path'))
            this.image.removeAttributeNS(null, 'clip-path');
         try {
            this.clip.replaceChild(croptool.svgobject.cloneNode(false), this.clip.firstChild);
         } catch (error) {
         }

         this.image.setAttribute( 'clip-path', 'url(#' + this.clip.getAttribute( 'id') + ')');
      }
   }
}

Image.prototype.disableDrag = function () {
   this.frameInfo = '';
   this.image.setAttribute( 'pointer-events', 'none');
   for (var frame in frames) {
      if (frames[frame].image && frames[frame].image === this) {
         frames[frame].image = null;
         break;
      }
   }
}
Image.prototype.enableDrag = function () {
   this.image.setAttribute( 'pointer-events', 'all');
}
Image.prototype.dragStyle = function () {
   this.image.setAttribute( 'style', this.dragstyle);
}
Image.prototype.dropStyle = function () {
   this.image.setAttribute( 'style', this.style);
}
Image.prototype.move = function (x, y) {
   if (this.image.hasAttributeNS(null, 'clip-path')) {
      this.clip.firstChild.setAttribute( 'transform', 'translate(' + (x + this.prevTransX) + ' ' + (y + this.prevTransY) + ')');
      if (this.image.hasAttributeNS(null, 'clip-path'))
         this.image.removeAttributeNS(null, 'clip-path');
      this.image.setAttribute( 'clip-path', 'url(#' + this.clip.getAttribute( 'id') + ')');
      this.image.setAttribute( "x", this.cropx + x);
      this.image.setAttribute( "y", this.cropy + y);
      this.curTransX = x + this.prevTransX;
      this.curTransY = y + this.prevTransY;
   } else {
      this.image.setAttribute( "x", this.x + x);
      this.image.setAttribute( "y", this.y + y);
   }
}
Image.prototype.resetSize = function (x, y) {
   if (parseFloat(this.image.getAttribute( "width")) != this.w || parseFloat(this.image.getAttribute( "height")) != this.h) {
      this.reset(x, y);
   }
}
Image.prototype.reset = function (x, y) {
   this.image.setAttribute( "width", this.w);
   this.image.setAttribute( "height", this.h);
   this.image.setAttribute( "x", x);
   this.image.setAttribute( "y", y);
   this.fix();
}
Image.prototype.fix = function () {
   this.x = parseFloat(this.image.getAttribute( "x"));
   this.y = parseFloat(this.image.getAttribute( "y"));
   if (this.image.hasAttributeNS(null, 'clip-path')) {
      this.prevTransX = this.curTransX;
      this.prevTransY = this.curTransY;
      this.cropx = this.x;
      this.cropy = this.y;
   } else {
      this.prevTransX = 0;
      this.prevTransY = 0;
      this.curTransX = 0;
      this.curTransY = 0;
   }
}
Image.prototype.info = function () {
   var x = (this.image.hasAttributeNS(null, 'clip-path')) ? this.cropx : this.image.getAttribute( "x");
   var y = (this.image.hasAttributeNS(null, 'clip-path')) ? this.cropy : this.image.getAttribute( "y");
   var s = this.image.getAttribute( 'id') + '=x:' + Math.round(parseFloat(x)) +
           ',y:' + Math.round(parseFloat(y)) +
           ',width:' + Math.round(parseFloat(this.image.getAttribute( "width"))) +
           ',height:' + Math.round(parseFloat(this.image.getAttribute( "height")));
   if (this.frameInfo != '')
      s += ',frame:' + this.frameInfo;
   if (this.image.hasAttributeNS(null, 'clip-path')) {
      s += ',clipped';
   }
   return  s;
}


function Frame(rect) {
   this.rect = rect;
   this.rect.setAttribute( 'onmouseout', 'outStyle(evt,"' + rect.getAttribute( 'style') + '")');
   this.rect.setAttribute( 'onmouseover', 'inStyle(evt,"' + rect.getAttribute(vectorprintprefix+'highlightstyle') + '")');
   this.rect.setAttribute( 'onclick', 'raiseFrame(evt.target)');
   this.x = parseFloat(rect.getAttribute( 'x'));
   this.y = parseFloat(rect.getAttribute( 'y'));
   this.w = parseFloat(rect.getAttribute( 'width'));
   this.h = parseFloat(rect.getAttribute( 'height'));
   this.multi = this.rect.hasAttribute(vectorprintprefix + 'multipleimages');
   this.checksize = ((this.rect.getAttribute(vectorprintprefix+'checksize') == 'false') ? false : true);
   this.checkinside = ((this.rect.getAttribute(vectorprintprefix+'checkinside') == 'false') ? false : true);
   if (this.multi == false) {
      this.fit = this.rect.getAttribute(vectorprintprefix+'fit');
      this.valign = this.rect.getAttribute(vectorprintprefix+'valign');
      this.align = this.rect.getAttribute(vectorprintprefix+'align');
   }
}
Frame.prototype.image = null;
Frame.prototype.rect = null;
Frame.prototype.x = 10;
Frame.prototype.y = 10;
Frame.prototype.w = 10;
Frame.prototype.h = 10;
Frame.prototype.fit = 'none';
Frame.prototype.align = 'none';
Frame.prototype.valgin = 'none';
Frame.prototype.multi = false;
Frame.prototype.checksize = true;
Frame.prototype.checkinside = true;
Frame.prototype.fill = function (image) {
   var fit = this.fit;
   var valign = this.valign;
   var align = this.align;
   if (!image.image.hasAttributeNS(null, 'clip-path')) {

      /*
       
       fitten en alignen doen we alleen als er niet gecropt is.
       
       */

      switch (fit) {
         case 'both':
            image.image.setAttribute( "width", this.w);
            image.image.setAttribute( "height", this.h);
            break;
         case 'width':
            ratio = parseFloat(image.image.getAttribute( "width")) / this.w;
            if (parseFloat(image.image.getAttribute( "height")) / ratio > this.h) {
               var ratio = parseFloat(image.image.getAttribute( "height")) / this.h;
               image.image.setAttribute( "height", this.h);
               image.image.setAttribute( "width", parseFloat(image.image.getAttribute( "width")) / ratio);
            } else {
               image.image.setAttribute( "width", this.w);
               image.image.setAttribute( "height", parseFloat(image.image.getAttribute( "height")) / ratio);
            }
            break;
         case 'height':
            var ratio = parseFloat(image.image.getAttribute( "height")) / this.h;
            if (parseFloat(image.image.getAttribute( "width")) / ratio > this.w) {
               ratio = parseFloat(image.image.getAttribute( "width")) / this.w;
               image.image.setAttribute( "width", this.w);
               image.image.setAttribute( "height", parseFloat(image.image.getAttribute( "height")) / ratio);
            } else {
               image.image.setAttribute( "width", parseFloat(image.image.getAttribute( "width")) / ratio);
               image.image.setAttribute( "height", this.h);
            }
            break;
         default:
            break;
      }
      var newx = parseFloat(image.image.getAttribute( "x"));
      switch (align) {
         case 'left':
            newx = this.x;
            break;
         case 'right':
            newx = this.x + this.w - parseFloat(image.image.getAttribute( "width"));
            break;
         case 'center':
            newx = this.x + ((this.w - parseFloat(image.image.getAttribute( "width"))) / 2);
            break;
         default:
            break;
      }
      if (image.image.hasAttributeNS(null, 'clip-path')) {
         image.prevTransX = ((newx - parseFloat(image.image.getAttribute( "x"))) + image.prevTransX);
         image.clip.firstChild.setAttribute( 'transform', 'translate(' + image.prevTransX + ' ' + image.prevTransY + ')');
         if (image.image.hasAttributeNS(null, 'clip-path'))
            image.image.removeAttributeNS(null, 'clip-path');
         image.image.setAttribute( 'clip-path', 'url(#' + image.clip.getAttribute( 'id') + ')');
      }
      image.image.setAttribute( "x", newx);
      var newy = parseFloat(image.image.getAttribute( "y"));
      switch (valign) {
         case 'top':
            newy = this.y;
            break;
         case 'bottom':
            newy = this.y + this.h - parseFloat(image.image.getAttribute( "height"));
            break;
         case 'center':
            newy = this.y + ((this.h - parseFloat(image.image.getAttribute( "height"))) / 2);
            break;
         default:
            break;
      }
      if (image.image.hasAttributeNS(null, 'clip-path')) {
         image.prevTransY = ((newy - parseFloat(image.image.getAttribute( "y"))) + image.prevTransY);
         image.clip.firstChild.setAttribute( 'transform', 'translate(' + image.prevTransX + ' ' + image.prevTransY + ')');
         if (image.image.hasAttributeNS(null, 'clip-path'))
            image.image.removeAttributeNS(null, 'clip-path');
         image.image.setAttribute( 'clip-path', 'url(#' + image.clip.getAttribute( 'id') + ')');
      }
      image.image.setAttribute( "y", newy);
   }
   if (this.image != null && this.image !== image && this.multi == false) {
      alert('There is already an image in this frame!');
      //image.reset(image.x, image.y);
   } else {
      var w = parseFloat(image.image.getAttribute( "width"));
      var h = parseFloat(image.image.getAttribute( "height"));
      var x = parseFloat(image.image.getAttribute( "x"));
      var y = parseFloat(image.image.getAttribute( "y"));
      if (image.image.hasAttributeNS(null, 'clip-path')) {
         w = image.clip.firstChild.getBBox().width;
         h = image.clip.firstChild.getBBox().height;
         x = image.clip.firstChild.getBBox().x + image.prevTransX;
         y = image.clip.firstChild.getBBox().y + image.prevTransY;
      }
      if ((this.w < w || this.h < h) && this.checksize == true) {
         alert('This image is too big for this frame!');
         //image.reset(image.x, image.y);
         image.frameInfo = '';
      } else {
         if ((x < this.x ||
                 x + w > this.x + this.w ||
                 y < this.y ||
                 y + h > this.y + this.h
                 ) && this.checkinside == true) {
            alert('This image is outside the frame!');
            //image.reset(image.x, image.y);
            image.frameInfo = '';
         } else {
            if (image.image.hasAttribute(vectorprintprefix + 'mindpi') && (parseFloat(image.image.getAttribute( "width")) > image.maxWidth ||
                    parseFloat(image.image.getAttribute( "height")) > image.maxHeight)) {
               alert('Resolution too low!');
               //image.reset(image.x, image.y);
               image.frameInfo = '';
            } else {
               this.image = image;
               image.frameInfo = this.rect.getAttribute( 'id');
            }
         }
      }
   }
}
function inStyle(evt, style) {
   if (dragobject && dragobject.resetSize) {
      evt.target.setAttribute( 'style', style);
   }
   showHelp('in dit kader moet een plaatje komen');
   raiseFrame(evt.target);
}
function outStyle(evt, style) {
   if (dragobject && dragobject.resetSize) {
      evt.target.setAttribute( 'style', style);
   }
   showHelp('');
}
function raiseFrame(target) {
   for (frame in frames) {
      if (target !== frames[frame].rect)
         target.parentNode.insertBefore(frames[frame].rect, target);
   }
}

function Ellipse() {
  this.svgobject = create('ellipse');
  this.svgobject.setAttribute( 'cx', this.cx);
  this.svgobject.setAttribute( 'cy', this.cy);
  this.svgobject.setAttribute( 'rx', this.rx);
  this.svgobject.setAttribute( 'ry', this.ry);
}
Ellipse.prototype.cx = 50;
Ellipse.prototype.cy = 50;
Ellipse.prototype.rx = 20;
Ellipse.prototype.ry = 20;
Ellipse.prototype.leftmargin = function () {
   return this.cx - margin;
};
Ellipse.prototype.rightmargin = function () {
   return this.cx + margin;
};
Ellipse.prototype.topmargin = function () {
   return this.cy + margin;
};
Ellipse.prototype.bottommargin = function () {
   return this.cy - margin;
};
Ellipse.prototype.svgobject = null;

Ellipse.prototype.move = function (x, y) {
   this.svgobject.setAttribute( 'cx', this.cx + x);
   this.svgobject.setAttribute( 'cy', this.cy + y);
}
Ellipse.prototype.reset = function () {
   this.svgobject.setAttribute( 'cx', this.cx);
   this.svgobject.setAttribute( 'cy', this.cy);
   this.svgobject.setAttribute( 'rx', this.rx);
   this.svgobject.setAttribute( 'ry', this.ry);
}
Ellipse.prototype.moveTo = function (x, y) {
   this.move(x - this.svgobject.getBBox().x, y - this.svgobject.getBBox().y);
}
Ellipse.prototype.resize = function (w, h) {
   this.svgobject.setAttribute( 'rx', w / 2);
   this.svgobject.setAttribute( 'ry', h / 2);
}
Ellipse.prototype.fix = function () {
   this.cx = parseFloat(this.svgobject.getAttribute( 'cx'));
   this.cy = parseFloat(this.svgobject.getAttribute( 'cy'));
   this.rx = parseFloat(this.svgobject.getAttribute( 'rx'));
   this.ry = parseFloat(this.svgobject.getAttribute( 'ry'));
}
Ellipse.prototype.setStyle = function (style) {
   this.svgobject.setAttribute( 'style', style);
}
Ellipse.prototype.disableDrag = function () {
   this.svgobject.setAttribute( 'pointer-events', 'none');
}
Ellipse.prototype.enableDrag = function () {
   this.svgobject.setAttribute( 'pointer-events', 'all');
}
Ellipse.prototype.sizeLeft = function (handle, x) {
   var newx = handle.x + x;
   if (newx + handle.w <= this.leftmargin()) {
      this.svgobject.setAttribute( 'rx', this.cx - newx - handle.w);
   }
}
Ellipse.prototype.sizeTop = function (handle, y) {
   var newy = handle.y + y;
   if (newy + handle.h <= this.bottommargin()) {
      this.svgobject.setAttribute( 'ry', this.cy - newy - handle.h);
   }
}
Ellipse.prototype.sizeRight = function (handle, x) {
   var newx = handle.x + x;
   if (newx >= this.rightmargin()) {
      this.svgobject.setAttribute( 'rx', newx - this.cx);
   }
}
Ellipse.prototype.sizeBottom = function (handle, y) {
   var newy = handle.y + y;
   if (newy >= this.topmargin()) {
      this.svgobject.setAttribute( 'ry', newy - this.cy);
   }
}
Ellipse.prototype.info = function () {
   var info = new Object();
   info['cx'] = this.cx;
   info['cy'] = this.cy;
   info['rx'] = this.rx;
   info['ry'] = this.ry;
   return info;
}

function Rectangle() {
  this.svgobject = create('rect');
  this.svgobject.setAttribute( 'x', this.x);
  this.svgobject.setAttribute( 'y', this.y);
  this.svgobject.setAttribute( 'width', this.w);
  this.svgobject.setAttribute( 'height', this.h);
}
Rectangle.prototype.x = 10;
Rectangle.prototype.y = 10;
Rectangle.prototype.w = 100;
Rectangle.prototype.h = 100;
Rectangle.prototype.leftmargin = function () {
   return this.x + margin;
}
Rectangle.prototype.rightmargin = function () {
   return this.x + this.w - margin;
}
Rectangle.prototype.topmargin = function () {
   return this.y + margin;
}
Rectangle.prototype.bottommargin = function () {
   return this.y + this.h - margin;
}
Rectangle.prototype.svgobject = null;

Rectangle.prototype.moveTo = function (x, y) {
   this.svgobject.setAttribute( "x", x);
   this.svgobject.setAttribute( "y", y);
}
Rectangle.prototype.move = function (x, y) {
   this.svgobject.setAttribute( "x", this.x + x);
   this.svgobject.setAttribute( "y", this.y + y);
}
Rectangle.prototype.reset = function () {
   this.svgobject.setAttribute( "x", this.x);
   this.svgobject.setAttribute( "y", this.y);
   this.svgobject.setAttribute( "width", this.width);
   this.svgobject.setAttribute( "height", this.height);
}
Rectangle.prototype.resize = function (w, h) {
   this.svgobject.setAttribute( "width", w);
   this.svgobject.setAttribute( "height", h);
}
Rectangle.prototype.fix = function () {
   this.x = parseFloat(this.svgobject.getAttribute( "x"));
   this.y = parseFloat(this.svgobject.getAttribute( "y"));
   this.w = parseFloat(this.svgobject.getAttribute( "width"));
   this.h = parseFloat(this.svgobject.getAttribute( "height"));
}
Rectangle.prototype.setStyle = function (style) {
   this.svgobject.setAttribute( 'style', style);
}
Rectangle.prototype.disableDrag = function () {
   this.svgobject.setAttribute( 'pointer-events', 'none');
}
Rectangle.prototype.enableDrag = function () {
   this.svgobject.setAttribute( 'pointer-events', 'all');
}
Rectangle.prototype.sizeLeft = function (handle, x) {
   var newx = handle.x + x;
   if (newx + handle.w <= this.rightmargin()) {
      this.svgobject.setAttribute( "x", newx + handle.w);
      this.svgobject.setAttribute( "width", this.w - x);
   }
}
Rectangle.prototype.sizeTop = function (handle, y) {
   var newy = handle.y + y;
   if (newy + handle.h <= this.bottommargin()) {
      this.svgobject.setAttribute( "y", newy + handle.h);
      this.svgobject.setAttribute( "height", this.h - y);
   }
}
Rectangle.prototype.sizeRight = function (handle, x) {
   var newx = handle.x + x;
   if (newx >= this.leftmargin()) {
      this.svgobject.setAttribute( "width", newx - this.x);
   }
}
Rectangle.prototype.sizeBottom = function (handle, y) {
   var newy = handle.y + y;
   if (newy >= this.topmargin()) {
      this.svgobject.getAttribute( "height", newy - this.y);
   }
}
Rectangle.prototype.info = function () {
   var info = new Object();
   info['x'] = this.x;
   info['y'] = this.y;
   info['w'] = this.w;
   info['h'] = this.h;
   return info;
}

function Croptool() {
   try {
      if (svgclipelement === 'ellipse') {
         Ellipse.call(this);
      } else if (svgclipelement === 'rect') {
         Rectangle.call(this);
      }
   } catch (error) {
      Rectangle.call(this);
   }
  this.svgobject.setAttribute( 'cursor', 'move');
  this.svgobject.setAttribute( 'onmouseover', "showHelp('gereedschap voor uitsnijden van plaatjes, vergroot/verklein het en sleep het boven een plaatje')");
  this.svgobject.setAttribute( 'onmouseout', "showHelp('')");
  Croptool.parent.setStyle.call(this, croptool_active_style);
  append(this.svgobject);
}

if (svgclipelement === 'ellipse') {
   Croptool.prototype = new Ellipse;
   Croptool.parent = Ellipse.prototype;
} else if (svgclipelement === 'rect') {
   Croptool.prototype = new Rectangle;
   Croptool.parent = Rectangle.prototype;
}

Croptool.prototype.constructor = Croptool;
Croptool.prototype.handles = new Object();
Croptool.prototype.guides = new Object();

Croptool.prototype.dragStyle = function () {
   Croptool.parent.setStyle.call(this, croptool_active_style);
}
Croptool.prototype.dropStyle = function () {
   Croptool.parent.setStyle.call(this, croptool_inactive_style);
}
Croptool.prototype.addHandles = function () {
   this.handles["tl"] = new TopLeftHandle();
   this.handles["tr"] = new TopRightHandle();
   this.handles["bl"] = new BottomLeftHandle();
   this.handles["br"] = new BottomRightHandle();
}
Croptool.prototype.addGuides = function () {
   this.guides['left'] = new LeftGuide();
   this.guides['right'] = new RightGuide();
   this.guides['top'] = new TopGuide();
   this.guides['bottom'] = new BottomGuide();
}
Croptool.prototype.positionGuidesAndHandles = function () {
   var x = this.svgobject.getBBox().x;
   var y = this.svgobject.getBBox().y;
   var w = this.svgobject.getBBox().width;
   var h = this.svgobject.getBBox().height;
   for (guide in this.guides) {
      this.guides[guide].position(x, y, w, h);
   }
   for (handle in this.handles) {
      this.handles[handle].position(x, y, w, h);
   }
}

Croptool.prototype.move = function (x, y) {
   Croptool.parent.move.call(this, x, y);
   this.positionGuidesAndHandles();
}
Croptool.prototype.fix = function () {
   Croptool.parent.fix.call(this);
   if (dragobject === this)
      this.fixHandles();
}
Croptool.prototype.fixHandles = function () {
   for (handle in this.handles) {
      this.handles[handle].fix();
   }
}

function Handle() {
   Rectangle.call(this);
  this.svgobject.setAttribute( 'style', fill);
  this.svgobject.setAttribute( 'rx', 2);
  this.svgobject.setAttribute( 'ry', 2);
  this.svgobject.setAttribute( 'cursor', 'pointer');
  this.svgobject.setAttribute( 'onmouseover', "showHelp('vergroot of verklein hiermee het uitsnede gereedschap')");
  this.svgobject.setAttribute( 'onmouseout', "showHelp('')");
  this.svgobject.setAttribute( "width", 5);
  this.svgobject.setAttribute( "height", 5);
  this.w = 5;
  this.h = 5;
  append(this.svgobject);
}
Handle.prototype = new Rectangle;
Handle.prototype.constructor = Handle;
Handle.parent = Rectangle.prototype;
Handle.prototype.info = null;
Handle.prototype.dragStyle = function (style) {
}
Handle.prototype.dropStyle = function (style) {
}
Handle.prototype.sizeBottom = '';
Handle.prototype.sizeTop = '';
Handle.prototype.sizeLeft = '';
Handle.prototype.sizeRight = '';

function TopLeftHandle() {
   Handle.call(this);
}
TopLeftHandle.prototype = new Handle;
TopLeftHandle.prototype.constructor = TopLeftHandle;
TopLeftHandle.parent = Handle.prototype;
TopLeftHandle.prototype.move = function (x, y) {
   if (dragobject === this) {
      croptool.sizeLeft(this, x);
      croptool.sizeTop(this, y);
      croptool.positionGuidesAndHandles();
   } else {
      Handle.parent.move.call(this, x, y);
   }
}
TopLeftHandle.prototype.position = function (x, y, width, height) {
   this.svgobject.setAttribute( "x", x - this.w);
   this.svgobject.setAttribute( "y", y - this.h);
}


function TopRightHandle() {
   Handle.call(this);
}

TopRightHandle.prototype = new Handle;
TopRightHandle.prototype.constructor = TopRightHandle;
TopRightHandle.parent = Handle.prototype;
TopRightHandle.prototype.move = function (x, y) {
   if (dragobject === this) {
      croptool.sizeRight(this, x);
      croptool.sizeTop(this, y);
      croptool.positionGuidesAndHandles();
   } else {
      Handle.parent.move.call(this, x, y);
   }
}
TopRightHandle.prototype.position = function (x, y, width, height) {
   this.svgobject.setAttribute( "x", x + width);
   this.svgobject.setAttribute( "y", y - this.h);
}


function BottomLeftHandle() {
   Handle.call(this);
}
BottomLeftHandle.prototype = new Handle;
BottomLeftHandle.prototype.constructor = BottomLeftHandle;
BottomLeftHandle.parent = Handle.prototype;
BottomLeftHandle.prototype.move = function (x, y) {
   if (dragobject === this) {
      croptool.sizeLeft(this, x);
      croptool.sizeBottom(this, y);
      croptool.positionGuidesAndHandles();
   } else {
      Handle.parent.move.call(this, x, y);
   }
}
BottomLeftHandle.prototype.position = function (x, y, width, height) {
   this.svgobject.setAttribute( "x", x - this.w);
   this.svgobject.setAttribute( "y", y + height);
}

function BottomRightHandle() {
   Handle.call(this);
}
BottomRightHandle.prototype = new Handle;
BottomRightHandle.prototype.constructor = BottomRightHandle;
BottomRightHandle.parent = Handle.prototype;
BottomRightHandle.prototype.move = function (x, y) {
   if (dragobject === this) {
      croptool.sizeRight(this, x);
      croptool.sizeBottom(this, y);
      croptool.positionGuidesAndHandles();
   } else {
      Handle.parent.move.call(this, x, y);
   }
}
BottomRightHandle.prototype.position = function (x, y, width, height) {
   this.svgobject.setAttribute( "x", x + width);
   this.svgobject.setAttribute( "y", y + height);
}

var dragged = false;
function Grab(evt)
{
   dragged = false;
   // op welk element hebben we geklikt
   var targetElement = evt.target;
//alert(targetElement);
   //    waarvandaan slepen we.....
   if (parseInt(evt.button) == 0 && !dragobject) {
      var transMatrix = targetElement.getCTM();
      GetTrueCoords(evt);
      GrabPoint.x = TrueCoords.x - transMatrix.e;
      GrabPoint.y = TrueCoords.y - transMatrix.f;

      //alert(targetElement);
      // we slepen alleen de rechthoek voor de uitsnede
      if (croptool && croptool.svgobject === targetElement)
      {

         dragobject = croptool;

      } else if (ok.rect === targetElement) {
         dragobject = ok;
      } else {
         for (var i in images) {
            if (images[i].image === targetElement && targetElement.getAttribute(vectorprintprefix+'dragallowed') === 'true') {
               dragobject = images[i];
               //dragobject.resetSize(GrabPoint.x, GrabPoint.y);
               break;
            }
         }
         if (croptool) {
            for (var handle in croptool.handles) {
               if (croptool.handles[handle].svgobject === targetElement) {
                  dragobject = croptool.handles[handle];
                  break;
               }
            }
         }
      }
      if (dragobject) {
         dragobject.disableDrag();
         dragobject.dragStyle();
      }
   } else if (parseInt(evt.button) == 2) {
      GetTrueCoords(evt);
      var transMatrix = targetElement.getCTM();
      GrabPoint.x = TrueCoords.x - transMatrix.e;
      GrabPoint.y = TrueCoords.y - transMatrix.f;
      for (var i in images) {
         if (images[i].image === targetElement) {
            if (confirm('Reset image?') == true)
               images[i].clean();
            statustext.data = images[i].info();
            break;
         }
      }
   }
}
;


function Drag(evt)
{
   // houdt rekening met zoomen en verschuiven

   if (dragobject) {
      dragged = true;
      GetTrueCoords(evt);
      statustext.data = 'x: ' + Math.round(TrueCoords.x) + 'y: ' + Math.round(TrueCoords.y);
      dragobject.move(TrueCoords.x - GrabPoint.x, TrueCoords.y - GrabPoint.y);
      if (dragobject === croptool) {
         var targetElement = evt.target;
         for (var image in images) {
            if (images[image].image === targetElement) {
               images[image].showCrop();
               break;
            }
         }
      }
   }
}
;

function raise(elem) {
   if (elem) {
      elem.parentNode.appendChild(elem);
   }
}

function Drop(evt)
{

   //alert(targetElement);
   if (dragobject) {
      var targetElement = evt.target;
      dragobject.dropStyle();
      dragobject.fix();
      for (var frame in frames) {
         if (frames[frame].rect === targetElement && dragobject.resetSize) {
            frames[frame].fill(dragobject);
            break;
         }
      }
      if (dragobject.sizeBottom === '') {
         croptool.fix();
         croptool.fixHandles();
      }
      //alert(instanceOf(dragobject,Handle));
      if (dragobject === croptool || dragobject.sizeBottom === '') {
         for (var image in images) {
            if (images[image].image === targetElement) {
               images[image].crop();
               statustext.data = images[image].info();
               break;
            }
         }
      }
      if (!dragged && ok === dragobject) {
         sendInfo();
      }
      dragobject.enableDrag();
      if (dragobject.info && dragobject !== croptool)
         statustext.data = dragobject.info();
   }

   dragobject = null;

}


function GetTrueCoords(evt)
{
   //    we passen de positie aan aan de huidige schaal (zoomen) en translatie (verschuiving)
   var x = evt.clientX;
   var y = evt.clientY;
   //    we passen de positie aan aan de huidige schaal (zoomen) en translatie (verschuiving)
   var scale = svg.currentScale;
   var translation = svg.currentTranslate;
   TrueCoords.x = ((x - translation.x) / scale);
   TrueCoords.y = ((y - translation.y) / scale);
   //alert(x + ' ' + y + ' '+ TrueCoords.x + ' ' + TrueCoords.y);
}

function instanceOf(object, constructorFunction) {
   while (object != null) {
      if (object == constructorFunction.prototype)
      {
         return true
      }
      object = object.__proto__;
   }
   return false;
}

function get(url, data) {
   return doAjax('GET', url, data);
}
function post(url, data) {
   return doAjax('POST', url, data );
}
var nrAjaxReq = 0;
function doAjax(method, url, data) {
   var ajax = new AjaxObject101(null, false);
	ajax.funcDone=function() {
        if (ajax.http.readyState==4&&ajax.http.status==200) {
        } else {
           alert("failed to send " + data + " to " + url);
        }
    }
   if (data && data.length > 2)
      data += '&ajaxnr=' + (++nrAjaxReq);
   else
      data = 'ajaxnr=' + (++nrAjaxReq);
   switch (method) {
      case "GET":
      case "POST":
         ajax.sndReq(method, url, data, false);
         break;
      default:
         alert(method + " not supported");
         return null;
   }
   if (ajax.http.readyState == 4 && ajax.http.status == 200)
   return ajax;
}

